{"version":3,"file":"use-async-queue.umd.js","sources":["../use-async-queue.js"],"sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react';\n\n/**\n * Hook for managing a queue with limited concurrency.\n * @param {number} concurrency - Maximum number of tasks to process\n * concurrently. Default 8.\n * @param {Function} inflight - Callback when a task changes from pending to\n * being processed.\n * @param {Function} done - Callback when a task is done being processed.\n * @param {Function} drain - Callback when all tasks are done.\n * @returns {object} Returns an object that exposes `add` and `stats`.\n */\nexport default function useAsyncQueue({\n  concurrency = 8,\n  done,\n  drain,\n  inflight,\n}) {\n  if (concurrency < 1) concurrency = Infinity;\n\n  const [stats, setStats] = useState({\n    numPending: 0,\n    numInFlight: 0,\n    numDone: 0,\n  });\n\n  const inFlight = useRef([]);\n  const pending = useRef([]);\n\n  useEffect(() => {\n    if (\n      stats.numDone > 0 &&\n      drain &&\n      inFlight.current.length === 0 &&\n      pending.current.length === 0\n    )\n      return drain();\n\n    while (\n      inFlight.current.length < concurrency &&\n      pending.current.length > 0\n    ) {\n      const task = pending.current.shift();\n      inFlight.current.push(task);\n      setStats((stats) => {\n        return {\n          ...stats,\n          numPending: stats.numPending - 1,\n          numInFlight: stats.numInFlight + 1,\n        };\n      });\n      inflight && inflight({ ...task, stats });\n      const result = task.task();\n      result\n        .then(() => {\n          inFlight.current.pop(task);\n          setStats((stats) => {\n            return {\n              ...stats,\n              numInFlight: stats.numInFlight - 1,\n              numDone: stats.numDone + 1,\n            };\n          });\n          done && done({ ...task, result, stats });\n        })\n        .catch(() => {\n          inFlight.current.pop(task);\n          setStats((stats) => {\n            return {\n              ...stats,\n              numInFlight: stats.numInFlight - 1,\n              numDone: stats.numDone + 1,\n            };\n          });\n          done && done({ ...task, result, stats });\n        });\n    }\n  }, [concurrency, done, drain, inflight, stats]);\n\n  const add = useCallback(\n    (task) => {\n      pending.current.push(task);\n      setStats((stats) => {\n        return {\n          ...stats,\n          numPending: stats.numPending + 1,\n        };\n      });\n    },\n    [pending]\n  );\n\n  return { add, stats };\n}\n"],"names":["concurrency","Infinity","useState","numPending","numInFlight","numDone","inFlight","useRef","pending","useEffect","stats","drain","current","length","task","shift","push","setStats","Object","inflight","result","then","pop","done","catch","useCallback"],"mappings":"qNAYe,+CACC,uCAKVA,EAAc,IAAGA,EAAcC,gBAETC,WAAS,CACjCC,WAAY,EACZC,YAAa,EACbC,QAAS,kBAGLC,EAAWC,SAAO,IAClBC,EAAUD,SAAO,WAEvBE,0BAEIC,EAAML,QAAU,GAChBM,GAC4B,IAA5BL,EAASM,QAAQC,QACU,IAA3BL,EAAQI,QAAQC,OAEhB,OAAOF,6BAMDG,EAAON,EAAQI,QAAQG,QAC7BT,EAASM,QAAQI,KAAKF,GACtBG,WAAUP,UACDQ,iBACFR,GACHP,WAAYO,EAAMP,WAAa,EAC/BC,YAAaM,EAAMN,YAAc,MAGrCe,GAAYA,EAASD,iBAAKJ,SAAMJ,SAC1BU,EAASN,EAAKA,OACpBM,EACGC,gBACCf,EAASM,QAAQU,IAAIR,GACrBG,WAAUP,UACDQ,iBACFR,GACHN,YAAaM,EAAMN,YAAc,EACjCC,QAASK,EAAML,QAAU,MAG7BkB,GAAQA,EAAKL,iBAAKJ,UAAMM,QAAQV,OAEjCc,iBACClB,EAASM,QAAQU,IAAIR,GACrBG,WAAUP,UACDQ,iBACFR,GACHN,YAAaM,EAAMN,YAAc,EACjCC,QAASK,EAAML,QAAU,MAG7BkB,GAAQA,EAAKL,iBAAKJ,UAAMM,QAAQV,QAnCpCJ,EAASM,QAAQC,OAASb,GAC1BQ,EAAQI,QAAQC,OAAS,QAqC1B,CAACb,EAAauB,EAAMZ,EAAOQ,EAAUT,IAejC,KAbKe,uBACTX,GACCN,EAAQI,QAAQI,KAAKF,GACrBG,WAAUP,UACDQ,iBACFR,GACHP,WAAYO,EAAMP,WAAa,OAIrC,CAACK,UAGWE"}